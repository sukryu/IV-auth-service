# 비밀번호 정책 및 해싱 전략

본 문서는 **ImmersiVerse Authentication Service**의 사용자 비밀번호 관리 원칙을 정의합니다. **비밀번호 복잡도**(길이, 문자 조합), **변경 주기**, 그리고 **비밀번호 해싱(Argon2id)** 방식에 대한 표준을 수립하여 계정 보안을 강화합니다.

---

## 1. 개요

- **인증 방식**: username/password → JWT 발급  
- **비밀번호 저장**: 평문 절대 금지, **Argon2id** 등 보안성 높은 해싱 사용  
- **주요 목표**:
  1. 사용자의 비밀번호가 유출되어도 역추적 어려운 형태로 안전하게 보관  
  2. 취약한 비밀번호·반복 사용 등으로 인한 계정 침해 최소화  
  3. 비밀번호 정책 준수 실패 시 사용자에게 명확히 안내

---

## 2. 비밀번호 정책

### 2.1 최소 길이 및 복잡도

1. **길이**: 최소 12자 권장(절대 최소 8~10자는 필요)  
2. **문자 조합**(가능하다면):
   - 대문자 + 소문자 + 숫자 + 특수문자 중 3가지 이상 포함  
   - 예) `"MyP@ssw0rd123"`  
3. **금지 패턴**: 
   - 사용자 이름, 이메일 일부와 동일한 문자열  
   - 단순/반복 패턴(`123456`, `aaaaaa`, `password`)  
4. **사용자 안내**:
   - 정책 불만족 시 `"비밀번호는 최소 12자 이상, 대소문자/숫자/특수문자 중 3종 이상을 포함해야 합니다."` 등 적절한 메시지

### 2.2 비밀번호 변경

- **주기적 변경**: 최신 보안 동향에서는 강제 주기보다는 사건 발생 시 즉각 변경이 더 효과적  
- **사용자 요청 시** 자유롭게 변경 가능  
- (선택) 이전 N개 비밀번호 재사용 금지(비밀번호 히스토리) → 구현 복잡도↑  
- 침해 징후 or 해킹 의심 시 즉시 변경 알림

### 2.3 실패 횟수 제한(Rate Limiting)

- **로그인 시 연속 5회 실패** → 임시 계정 잠금(10~30분) or CAPTCHA  
- Redis 등에서 실패 횟수 카운트 → 일정 횟수 초과 시 차단

---

## 3. 비밀번호 해싱(Argon2id)

### 3.1 알고리즘 선정

- **Argon2id**: 메모리 하드 KDF, GPU 병렬 공격 내성  
- 대안: Bcrypt(cost≥12), PBKDF2(HMAC-SHA256), Scrypt 등 → 현재 Argon2id 권장

### 3.2 Argon2id 파라미터 예시

- `timeCost`=3  
- `memoryCost`=64*1024 (64MB)  
- `threads`=1 or 2  
- `hashLength`=32  
- 실제 값은 서버 성능, 로그인 TPS 등에 맞춰 조정. 
  - 테스트 후 200ms 이내 처리되도록(팀이 원하는 사용자 경험과 서버 자원 고려)

### 3.3 솔트(Salt) & 페퍼(Pepper)

1. **솔트**:
   - 16~32바이트 난수  
   - 사용자마다 고유. DB `password_hash` 필드에 저장  
   - Argon2id 호출 시 `(password + pepper, salt)`  
2. **페퍼**(선택):
   - 전역 시크릿. Vault/HSM 등에 보관  
   - 해싱 전 password에 pepper를 추가 → 유출 시 교체 가능  
   - 운영 복잡도↑, 필요 시만 사용

### 3.4 해싱 결과 저장 형식

- PHC(Password Hashing Competition) 표준 문자열 예:  
  ```text
  $argon2id$v=19$m=65536,t=3,p=1$<salt>$<hash>
  ```
- DB 테이블 `users.password_hash`에 저장  
- 검증 시 파라미터/솔트/해시를 parse → Argon2id 동일 호출 → 비교

---

## 4. 구현 흐름 (회원가입·로그인)

### 4.1 회원가입 시

1. 비밀번호 정책(길이, 복잡도) 검증  
2. Argon2id 해싱 → `users.password_hash` 저장  
3. DB Insert

### 4.2 로그인 시

1. DB 조회 → `password_hash` 획득  
2. Argon2id 동일 파라미터로 해싱 비교  
3. 일치하면 로그인 성공, 불일치하면 401 Unauthorized + 실패 횟수↑

---

## 5. 운영 보안 고려

1. **민감 로그**: 비밀번호 평문 노출 금지  
2. **DB 유출 대비**: Argon2id 해싱으로 역추적 최소화  
3. **비밀번호 재설정(Reset)**: 이메일 인증/2FA 등으로 본인 확인  
4. **성능 모니터링**: Argon2id cost가 너무 높으면 로그인 지연→CPU 부하

---

## 6. 테스트 & 모니터링

- **단위 테스트**: 비밀번호 해싱 함수, 여러 길이/문자열 case test  
- **리얼로드 테스트**: 고동시 로그인 TPS 시 Argon2id 성능 검토  
- **오류 추적**: "login failed" 로그 증가 시 보안 침해 시나리오 모니터링

---

## 7. 결론

본 **비밀번호 정책** 및 **Argon2id 해싱** 전략을 준수함으로써:

1. 안전한 비밀번호 보관(단방향 KDF)  
2. 사용자에게 일정 수준 복잡도 요구  
3. 침해 상황 발생 시 피해 최소화(해싱 강화)  
4. 필요한 경우 2FA/MFA, IP 제한 등 추가 보안 확장 가능

팀원들은 변경(예: 해싱 파라미터 상향, 길이 규칙 강화) 시 본 문서를 갱신하고, 사용자에게 안내하여 서비스 전반의 보안을 유지해 주세요.