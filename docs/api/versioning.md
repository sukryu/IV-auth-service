# API 버전 관리 전략

본 문서는 **ImmersiVerse Authentication Service**가 제공하는 API의 **버전 관리**(Versioning) 방식을 정의합니다. gRPC 및 REST(through API Gateway) 모두 일관된 원칙을 따르며, 하위 호환성을 최대한 유지하면서 새로운 기능과 변경 사항을 도입할 수 있는 절차를 안내합니다.

---

## 1. 개요

- **마이크로서비스 아키텍처**를 적용했으므로, 각 서비스는 독립적으로 발전할 수 있다.
- **Auth Service**는 gRPC 인터페이스(**proto/auth/v1**)와 REST Gateway 변환을 통해 API를 외부에 노출.
- **버전**은 크게 **메이저**, **마이너**로 구분:
  - **메이저 버전**(`v1`, `v2`)은 **하위 호환**을 깨는 변경 시 사용.
  - **마이너/패치 버전**(`v1.1`, `v1.2` 등)은 하위 호환을 유지하면서 필드 추가, 버그 수정 등을 수행.

---

## 2. 버전 네임스페이스

### 2.1 gRPC 패키지명

- `proto/auth/v1`: 현재 사용 중인 패키지 (예: `auth.v1`)
- 추후 하위 호환성이 깨지는 변경이 발생하면 `proto/auth/v2` 등 별도 디렉토리/패키지 생성
- **중요 원칙**: `v1` 프로토를 직접 수정할 때는 **하위 호환**(Backward Compatibility)을 깨지 않는 범위에서만 변경(필드 추가, reserved 키워드 이용 등)

### 2.2 REST 엔드포인트 버전

- API Gateway 기준으로 `/auth/v1/...` 형태의 경로를 사용 (예: `/auth/v1/login`, `/auth/v2/login`).
- **새 메이저 버전**: `/auth/v2/...` 경로 추가. 
- 구 버전(`v1`)은 일정 기간 병행 운영 → 클라이언트 마이그레이션 기간을 부여.

---

## 3. 하위 호환성(Backward Compatibility)

### 3.1 Proto3에서의 호환성 지침

- **새 필드 추가**: 기존 메시지에 새 필드를 추가하는 것은 호환 가능(번호 충돌 안 나게 주의).
- **필드 삭제/이름 변경**: 실제로는 제거하지 않고 `reserved`로 선언(또는 deprecated 어노테이션) → 완전 삭제는 메이저 버전 업에서만.
- **Enum** 확장**: 새 enum 값은 추가 가능. 하지만 클라이언트가 알 수 없는 enum 값이 들어올 수 있음을 고려(기본 fallback 처리가 필요).

### 3.2 gRPC 메서드 변경

- **메서드 추가**: 기존 서비스에 새 RPC 추가는 하위 호환 유지(클라이언트는 사용 안 하면 됨).
- **메서드 시그니처 변경**: 파라미터/응답 구조가 바뀌거나 필수 필드가 늘어나는 등 호환 깨질 시, 새 메서드를 도입하고 구 메서드는 deprecated(이후에 제거).
- **서비스명 변경**: 메이저 버전 업에서만 가능.

### 3.3 REST Path 변경

- `/auth/v1/login` → `/auth/v1/signin` 식으로 변경할 경우, 기존 `/auth/v1/login`을 일정 기간 유지(deprecated)하고 문서상 안내.

---

## 4. 메이저 버전 업

### 4.1 시나리오

- 기존 API와 호환 불가한 대규모 변경(토큰 구조 변경, 인증 로직 재설계 등)이 필요할 때.
- `auth.v2` 패키지/디렉토리로 새 `.proto` 작성, `AuthServiceV2` (또는 동일 이름이라도 proto-level package가 다르기 때문에 문제 없음).
- REST 경로 `POST /auth/v2/...`.

### 4.2 병행 운영

- `v1`과 `v2`를 **동시 운영**하여 클라이언트가 점진적으로 마이그레이션 가능.
- 운영팀은 일정 기간 후 `v1` 중단 일정을 공지.

### 4.3 중단(Deprecated) 정책

- **Deprecated 단계**: 문서/SDK에서 `v1` 메서드를 deprecated로 표시.  
- **EOL(End of Life)**: 일정 시점 도래 시 `v1` 실제 종료.

---

## 5. 마이너/패치 업

### 5.1 메시지 필드 추가

- 예: `LoginResponse`에 `user_id` 필드를 추가.  
- 구 클라이언트는 새 필드를 무시 → 하위 호환성 OK.
- 문서에 **추가된 필드**, **버전**(e.g. `v1.1.0`) 표기.

### 5.2 에러 코드 확장

- 새 에러 상황이 생기면(예: `AUTH_TOTP_REQUIRED`), `ErrorInfo`에 새 code 할당 → 구 클라이언트는 모르는 code라도 graceful degrade 하도록.

### 5.3 문서화

- 릴리스 노트에 **마이너 버전**(예: `v1.2.3`) 추가된 필드/메서드/에러 코드 기록.
- 마이너 버전은 별도 proto 패키지 경로(`auth.v1`)는 유지, .proto 내부에서만 변경.

---

## 6. 구현 절차 요약

1. **하위 호환 가능 변경** → 기존 `auth.v1` 유지, 새 필드 or 메서드를 추가.  
2. **하위 호환 불가**(Major Breaking) → `auth.v2` 폴더/패키지 생성, 새 메시지/서비스 정의.  
3. **동시 운영** → 구 버전(`v1`) 점진적 deprecation, 일정 이후 EOL.  
4. **Doc & Release Note**: 변경 내용 공개, 마이그레이션 가이드 제공.

---

## 7. 클라이언트 마이그레이션 지침

- **REST**: 기존 클라이언트는 `/auth/v1/...`를 사용, 새 기능은 `/auth/v2/...`.  
- **gRPC**: 클라이언트가 `proto/auth/v2`를 임포트해 새 Stub 사용.  
- 마이그레이션 시:
  - Test → Stage → Prod 순으로 점진 적용  
  - 새 API 동작 확인 후, 구 API 호출 제거

---

## 8. 예시 버전 시나리오

- **v1.0.0**(초기) - Login, Logout, CreateUser 등
- **v1.1.0** - `LoginResponse`에 `user_id` 필드 추가 (하위 호환)
- **v1.2.0** - `RefreshToken` 메서드 추가 (하위 호환)
- **v2.0.0** - 메이저 변경: JWT 구조 변경, `User` 스키마 대폭 수정.  
  - `/auth/v2/...` REST  
  - `auth.v2` proto
  - 6개월 뒤 v1 EOL

---

## 9. 테스트 및 문서 업데이트

- 새 버전 배포 전, **통합 테스트**(v1 + v2 병행)  
- 문서(`docs/api` 하위), `.proto` 주석, 예제 코드에 버전 표기
- API Gateway가 v1/v2 라우팅 구분 여부 확인

---

## 10. 결론

**버전 관리**는 **인증 API**의 신뢰성과 호환성을 유지하는 핵심 전략입니다.  
- **사소한 변경**(필드 추가, 버그 수정)은 `v1` 내 마이너/패치로 대응, 하위 호환 유지.  
- **큰 구조 변화**는 `v2` 등 **메이저 버전**을 생성하고 병행 운영.  
- **문서 & 릴리스 노트**에서 변경점과 마이그레이션 가이드를 명확히 안내.  